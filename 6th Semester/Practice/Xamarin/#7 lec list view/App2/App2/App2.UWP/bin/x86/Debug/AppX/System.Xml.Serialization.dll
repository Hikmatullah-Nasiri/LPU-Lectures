<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="XmlFoundEndOfFile" xml:space="preserve">
    <value>end of file</value>
  </data>
  <data name="InterfaceTypeCannotBeCreated" xml:space="preserve">
    <value>Interface type '{0}' cannot be created. Consider replacing with a non-interface serializable type.</value>
  </data>
  <data name="JsonServerTypeSpecifiedForInvalidDataType" xml:space="preserve">
    <value>Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.</value>
  </data>
  <data name="QuotaCopyReadOnly" xml:space="preserve">
    <value>Cannot copy XmlDictionaryReaderQuotas. Target is readonly.</value>
  </data>
  <data name="XmlEncodingNotSupported" xml:space="preserve">
    <value>XML encoding not supported.</value>
  </data>
  <data name="InvalidXmlDataContractName" xml:space="preserve">
    <value>XML data contract Name for type '{0}' cannot be set to null or empty string.</value>
  </data>
  <data name="FactoryTypeNotISerializable" xml:space="preserve">
    <value>Factory type '{0}' for ISerializable type '{1}' must also be ISerializable.</value>
  </data>
  <data name="JsonEncounteredUnexpectedCharacter" xml:space="preserve">
    <value>Encountered unexpected character '{0}'.</value>
  </data>
  <data name="XmlUnexpectedEndElement" xml:space="preserve">
    <value>No matching start tag for end element.</value>
  </data>
  <data name="JsonInvalidDateTimeString" xml:space="preserve">
    <value>DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.</value>
  </data>
  <data name="GenericParameterNotValid" xml:space="preserve">
    <value>In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</value>
  </data>
  <data name="ArrayExceededSize" xml:space="preserve">
    <value>Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.</value>
  </data>
  <data name="ErrorTypeInfo" xml:space="preserve">
    <value>of type {0}</value>
  </data>
  <data name="GenericTypeNotExportable" xml:space="preserve">
    <value>Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</value>
  </data>
  <data name="JsonDuplicateMemberNames" xml:space="preserve">
    <value>The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.</value>
  </data>
  <data name="XmlEndElementNoOpenNodes" xml:space="preserve">
    <value>No corresponding start element is open.</value>
  </data>
  <data name="JsonEncodingNotSupported" xml:space="preserve">
    <value>Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.</value>
  </data>
  <data name="InvalidEnumValueOnWrite" xml:space="preserve">
    <value>Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</value>
  </data>
  <data name="ValueTypeCannotHaveRef" xml:space="preserve">
    <value>ValueType '{0}' cannot have ref to another object.</value>
  </data>
  <data name="QuotaMustBePositive" xml:space="preserve">
    <value>Quota must be a positive value.</value>
  </data>
  <data name="NoConversionPossibleTo" xml:space="preserve">
    <value>An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.</value>
  </data>
  <data name="InvalidLocalNameEmpty" xml:space="preserve">
    <value>The empty string is not a valid local name.</value>
  </data>
  <data name="PlatformNotSupported_MtomEncoding" xml:space="preserve">
    <value>The Message Transmission Optimization Mechanism (MTOM) message encoding is not supported on this platform.</value>
  </data>
  <data name="CollectionTypeHasMultipleDefinitionsOfInterface" xml:space="preserve">
    <value>{0} has multiple definitions of interface '{1}'.</value>
  </data>
  <data name="XmlAsyncIsRunningException" xml:space="preserve">
    <value>An asynchronous operation is already in progress.</value>
  </data>
  <data name="InvalidEnumValueOnRead" xml:space="preserve">
    <value>Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.</value>
  </data>
  <data name="NullKnownType" xml:space="preserve">
    <value>One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.</value>
  </data>
  <data name="PlatformNotSupported_NetDataContractSerializer" xml:space="preserve">
    <value>System.Runtime.Serialization.NetDataContractSerializer is not supported on this platform.</value>
  </data>
  <data name="InvalidXmlDeserializingExtensionData" xml:space="preserve">
    <value>The XML encountered when deserializing extension data is invalid.</value>
  </data>
  <data name="TooManyIgnoreDataMemberAttributes" xml:space="preserve">
    <value>Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</value>
  </data>
  <data name="ErrorDeserializing" xml:space="preserve">
    <value>There was an error deserializing the object {0}. {1}</value>
  </data>
  <data name="PartialTrustIXmlSerialzableNoPublicConstructor" xml:space="preserve">
    <value>The IXmlSerializable type '{0}' cannot be deserialized because it does not have a public parameterless constructor. Adding a public parameterless constructor will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</value>
  </data>
  <data name="XmlInvalidCharRef" xml:space="preserve">
    <value>Character reference not valid.</value>
  </data>
  <data name="ValueMustBeNonNegative" xml:space="preserve">
    <value>The value of this argument must be non-negative.</value>
  </data>
  <data name="XmlConversionOverflow" xml:space="preserve">
    <value>The value '{0}' cannot be represented with the type '{1}'.</value>
  </data>
  <data name="XmlInvalidUniqueId" xml:space="preserve">
    <value>UniqueId cannot be zero length.</value>
  </data>
  <data name="ValueTypeCannotHaveBaseType" xml:space="preserve">
    <value>Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</value>
  </data>
  <data name="XmlFullStartElementExpected" xml:space="preserve">
    <value>Non-empty start element expected. Found {0}.</value>
  </data>
  <data name="XmlWriterMustBeInElement" xml:space="preserve">
    <value>WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.</value>
  </data>
  <data name="XmlDeclNotFirst" xml:space="preserve">
    <value>No characters can appear before the XML declaration.</value>
  </data>
  <data name="DataMemberOnEnumField" xml:space="preserve">
    <value>Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead.</value>
  </data>
  <data name="XmlArrayTooSmallOutput" xml:space="preserve">
    <value>Array too small.  Must be able to hold at least {0}.</value>
  </data>
  <data name="XmlWriterClosed" xml:space="preserve">
    <value>The XmlWriter is closed.</value>
  </data>
  <data name="XmlArrayTooSmall" xml:space="preserve">
    <value>Array too small.</value>
  </data>
  <data name="CollectionMustHaveAddMethod" xml:space="preserve">
    <value>Collection type '{0}' does not have a valid Add method.</value>
  </data>
  <data name="JsonXmlProcessingInstructionNotSupported" xml:space="preserve">
    <value>Processing instructions (other than the XML declaration) are not supported.</value>
  </data>
  <data name="FactoryObjectContainsSelfReference" xml:space="preserve">
    <value>Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.</value>
  </data>
  <data name="XmlInvalidSurrogate" xml:space="preserve">
    <value>Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.</value>
  </data>
  <data name="AssemblyNotFound" xml:space="preserve">
    <value>Assembly '{0}' is not found.</value>
  </data>
  <data name="XmlInvalidQualifiedName" xml:space="preserve">
    <value>Expected XML qualified name. Found '{0}'.</value>
  </data>
  <data name="TooManyCollectionContracts" xml:space="preserve">
    <value>Type '{0}' has more than one CollectionDataContractAttribute attribute.</value>
  </data>
  <data name="InvalidXsRefDefinition" xml:space="preserve">
    <value>Invalid Ref '{0}'. Must not be null or empty.</value>
  </data>
  <data name="JsonInvalidRootElementName" xml:space="preserve">
    <value>Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.</value>
  </data>
  <data name="PartialTrustDataContractTypeNotPublic" xml:space="preserve">
    <value>The data contract type '{0}' is not serializable because it is not public. Making the type public will fix this error. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</value>
  </data>
  <data name="KnownTypeAttributeEmptyString" xml:space="preserve">
    <value>Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</value>
  </data>
  <data name="DataContractNamespaceIsNotValid" xml:space="preserve">
    <value>DataContract namespace '{0}' is not a valid URI.</value>
  </data>
  <data name="NoGetMethodForProperty" xml:space="preserve">
    <value>No get method for property '{1}' in type '{0}'.</value>
  </data>
  <data name="JsonCannotWriteTextAfterNonTextAttribute" xml:space="preserve">
    <value>Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.</value>
  </data>
  <data name="XmlLineInfo" xml:space="preserve">
    <value>Line {0}, position {1}.</value>
  </data>
  <data name="DcTypeNotResolvedOnDeserialize" xml:space="preserve">
    <value>Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.</value>
  </data>
  <data name="XmlStartElementLocalNameNsExpected" xml:space="preserve">
    <value>Start element '{0}' from namespace '{1}' expected. Found {2}.</value>
  </data>
  <data name="JsonMustSpecifyDataType" xml:space="preserve">
    <value>You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.</value>
  </data>
  <data name="GetOnlyCollectionMustHaveAddMethod" xml:space="preserve">
    <value>Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection&lt;T&gt;.</value>
  </data>
  <data name="CallbackParameterInvalid" xml:space="preserve">
    <value>Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'. </value>
  </data>
  <data name="XmlMaxArrayLengthExceeded" xml:space="preserve">
    <value>The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.</value>
  </data>
  <data name="JsonDuplicateMemberInInput" xml:space="preserve">
    <value>The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.</value>
  </data>
  <data name="TypeNotSerializable" xml:space="preserve">
    <value>Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute. Alternatively, you can ensure that the type is public and has a parameterless constructor - all public members of the type will then be serialized, and no attributes will be required.</value>
  </data>
  <data name="JsonXmlInvalidDeclaration" xml:space="preserve">
    <value>XML declaration can only be written at the beginning of the document.</value>
  </data>
  <data name="JsonCannotWriteStandaloneTextAfterQuotedText" xml:space="preserve">
    <value>Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.</value>
  </data>
  <data name="JsonUnexpectedAttributeLocalName" xml:space="preserve">
    <value>Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.</value>
  </data>
  <data name="InvalidEnumMemberValue" xml:space="preserve">
    <value>'{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.</value>
  </data>
  <data name="JsonSizeExceedsRemainingBufferSpace" xml:space="preserve">
    <value>The specified size exceeds the remaining buffer space ('{0}' bytes).</value>
  </data>
  <data name="DuplicateAttribute" xml:space="preserve">
    <value>Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'. </value>
  </data>
  <data name="XmlFullStartElementLocalNameNsExpected" xml:space="preserve">
    <value>Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.</value>
  </data>
  <data name="JsonNodeTypeArrayOrObjectNotSpecified" xml:spac